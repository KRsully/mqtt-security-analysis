\documentclass[12pt]{article}

\usepackage{url}
\usepackage{graphicx}
\usepackage{tabulary}
\renewcommand{\baselinestretch}{1.5}

\begin{document}
\input{titlepage}
\begin{abstract}
	This paragraph will contain an abstract summarizing the project.
\end{abstract}
\input{acks}
\tableofcontents
\listoffigures
\section{Introduction}
The Internet of Things (IoT) is the ever-growing system of physical devices that communicate with each other over the Internet.  Many of these devices are small, low-power devices with little computing power, such as temperature sensors. MQTT (Message Queuing Telemetry Transport) is a messaging protocol that is widely used by devices in the IoT (Internet of Things) due to its lightweight computing requirements. \par

The MQTT organization claims that MQTT is used in the following industries: automotive, logistics, manufacturing, smart home, consumer products, and transportation \cite{mqtt-org}. Cyber attacks against industrial targets are increasing, and adding networked devices increases the potential attack surface. If devices in industrial networks are using MQTT for communication, there is a need to understand just how secure implementations of the protocol are.\par
As the number of devices in the IoT continues to grow, so does the number of devices that use MQTT. As such, there is the need to evaluate the security of the MQTT protocol so the risk posed by including devices that communicate using MQTT in a computer network is better quantifiable.
\section{Background}
\subsection{MQTT}
MQTT follows a publish-subscribe model, where MQTT clients can publish messages to and/or subscribe to receive messages from topics that are hosted by an MQTT broker. This provides the ability to send a message to many devices that are subscribed to a topic simultaneously by having a single client publish a message to the topic. \par
MQTT supports username-and-password-based authentication, however MQTT communications are not encrypted. The MQTT 3.1.1 specification notes that ``As a transport protocol, MQTT is concerned only with message transmission and it is the implementerâ€™s responsibility to provide appropriate security features.''\cite{mqtt3.1.1}, and the MQTT 5.0 specification shares the same sentiment\cite{mqtt5.0}. Both specifications provide some suggestions on considerations when implementing secure MQTT software, and both strongly recommend using TLS to provide security for communications. However, it is emphasized that the burden of security lies on the implementer. 
\subsection{MQTT Over TLS}
MQTT packets sent over a TCP/IP connection can be encrypted using TLS. This adds an additional step to the MQTT connection process, as shown in Figure \ref{fig:connection}.\par
\begin{figure}[!htb]
\centering
	\includegraphics[scale=0.5]{tcp-tls-mqtt.png}
	\caption{MQTT-Over-TLS Connection Process\label{fig:connection}}
\end{figure}
As such, using TLS increases the computation and network resources used when communicating. This is incongruent with MQTT's goal to be a lightweight protocol for low-power, low-resource devices, and adds complexity to the implementation of a properly secure MQTT software.\par
This report will focus on the implementation of TLS using digital certificates. There are 3 ways that certificate-based TLS is implemented in the case of an MQTT system:
\begin{enumerate}
	\item The broker has a certificate that is provided to clients that initialize the TLS handshake
	\begin{itemize}
		\item In this case, neither the broker nor the client authenticate each other
	\end{itemize}
	\item Clients keep a copy of trusted certificates, and check the certificate provided by the broker against their trusted certificates
	\begin{itemize}
		\item In this case, the client authenticates the broker
	\end{itemize}
	\item Clients pass a copy of their own certificate to the broker after verifying the broker's certificate, and the broker verifies that the client certificate has been signed by a trusted CA
	\begin{itemize}
		\item In this case, the broker and the client authenticate each other
	\end{itemize}
\end{enumerate}
As the TLS handshake occurs before the start of MQTT communication, troubleshooting MQTT over TLS is challenging. When an error occurs in the TLS handshake, it is almost always deemed fatal and by TLS protocol the broker and client must end their connection\cite{tls1.2errors}. Therefore, the broker and client are not able to engage in MQTT communications, requiring that errors be relayed between broker and client through the TLS header.

\section{Experiment Setup}
\par Data was gathered using two computers communicating over a local network. One computer hosted two brokers: one mosquitto broker, and one HiveMQ CE broker. The other computer used mosquitto\_pub and Paho clients to send messages to the brokers.\par
OpenSSL 1.1.1f was used to generate a CA key for the mosquitto broker, which was then used to generate self-signed CA certificates and to sign broker and client certificates.\par
keytool was used to generate Java keystores, truststores, and certificates for the HiveMQ broker and clients.
broker 1 mosquitto version 1.6.9, Ubuntu 20.04.2 LTS 64-bit\\
broker 2 HiveMQ CE version 2020.2, Ubuntu 20.04.2 LTS 64-bit\\
client 1 mosquitto version 2.0.8, Windows Subsystem for Linux 4.4.0-19041-Microsoft 64-bit\\


\section{Tools Developed}
\subsection{Golang MQTT Packet Decoding}
Golang's \texttt{gopacket} library provides an API for capturing and decoding packets from a network interface. The \texttt{layers} library does not contain layers for MQTT packets, so a collection of layers was created for each control packet type, as well as the MQTT fixed header. 
\subsection{Golang Packet Capture}
To accompany the MQTT layer decoders, a CLI packet capturing utility was built in Golang. 
\section{MQTT over TLS using Certificates}

\begin{tabular}{  c | c  c c}
CA Cert 			& valid & valid & valid \\
Server Cert 		& valid & valid & valid \\
Server Verify Cert & valid & valid & valid \\
Client Cert		& not required; not provided & required; valid & required; expired \\
\hline
Expected TLS Error Alert & none & none & certificate\_expired
\end{tabular}
\subsection{Relaying Error Messages Through an Unencrypted Listener}
One option to relay additional information to the client in the case that the TLS handshake in unsuccessful is for the broker to publish error messages and troubleshooting information to some unencrypted listener. 

\section{Maximum MQTT Packet Size}
Mentioned in the MQTT specifications, an MQTT control packet's greatest possible size is 268, 435, 455 bytes (256 MiB less one byte). The only types of control packets that can achieve this length within the rules of the protocol are PUBLISH packets or SUBSCRIBE packets. The greatest possible payload for a MQTT 3.1.1 PUBLISH packet would be: 268, 435, 455 minus 1 byte for the packet type and flags, 4 bytes for the `Remaining Length', 2 bytes of the topic name length, and at minimum 1 byte of topic name, resulting in a payload of 256 MiB minus 9 bytes.\par
The greatest possible payload for a MQTT 3.1.1 SUBSCRIBE packet would be: 268, 435, 455 minus 1 byte for packet type and flags, 4 bytes for the `Remaining Length', 2 bytes for the packet identifier, resulting in 256 MiB minus 8 bytes to be used to encode topic subscriptions. Each topic subscription requires 2 bytes for the topic name length, up to 65535 bytes for the topic name, and 1 byte for the desired QoS | allowing for at most 4095 maximum-size topic subscriptions. In the case of MQTT 5.0, these sizes are equal or lesser given that the variable header of each packet may contain bytes representing packet properties.\par
Given that MQTT is meant to be a lightweight protocol that uses few network resources, we would expect that MQTT clients and brokers will be sending control packets that are much smaller than the maximum packet size. Therefore, it would be reasonable that MQTT brokers enforce a default maximum packet size that is smaller than the maximum packet size to ensure that malicious actors cannot cause congestion by sending many large packets to the broker. \par
However, we see that in the case of both HiveMQ and mosquitto the default setting is that the maximum packet size is 256 MiB. Both softwares also allow for a maximum of 1000 queued messages per client. 
\subsection{MQTT Message Queueing Attack}
An attacker could easily disrupt the broker by:
\begin{enumerate}
	\item Creating a persistent session between any number of clients and the broker by having each client subscribe to any number of distinct topics with either QoS 1 or 2
	\item Disconnecting the clients so that the messages sent to each topic that the clients subscribed to are queued by the broker for later delivery to the offline clients
	\item Use a different client (or clients) to publish up to 1000 maximum-sized messages to each topic that the clients subscribed to
\end{enumerate}
Depending on the resources of the machine hosting the broker, simply keeping the queued messages could result in depleting the resources allocated to the broker's process as 1000 full-size messages requires 256,000 MiB, or approximately 268 GB of memory.\par
In the case that the broker is able to store all of the queued messages, we can then slow down communication between the broker and its non-malicious clients by reconnecting our clients to the topic that they subscribed to. Since the default for both brokers is to never expire client sessions, we can reconnect our clients and begin to receive the queued messages at any time. mosquitto applies a default of a maximum of 20 messages to be inflight at a time with no maximum on the amount of inflight bytes, so if we have enough malicious clients we can request that mosquitto attempt to send 5120 MiB of packets to our clients. HiveMQ's documentation does not clearly state if it is possible to limit the amount of outgoing messages\cite{hivemq-bw}. Depending on the network used to relay these messages, this could take a significant amount of time. In addition, as these are QoS 1 or 2 messages the broker will keep attempting to publish the message to the subscribing clients until the clients respond with a publish acknowledgement control packet. We could have our malicious clients never respond with the publish acknowledgement, forcing the broker to continue to retry publishing forever. 
\subsection{Mitigating the MQTT Message Queueing Attack Through Safe Defaults}

\section{Future Work}
Retrieving TLS session keys from local MQTT traffic for debugging purposes?

\end{tabulary}
\bibliographystyle{apalike}
\bibliography{comp4905}
\end{document}